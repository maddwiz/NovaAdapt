<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#1f6f5f" />
  <title>NovaAdapt Realtime Console</title>
  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.5.0/css/xterm.min.css" />
  <style>
    :root {
      --bg: #f3f0e9;
      --panel: #fffaf1;
      --panel-2: #f8eed9;
      --ink: #1f1a14;
      --muted: #685f53;
      --line: #c9b89d;
      --brand: #1f6f5f;
      --brand-2: #2f8f7c;
      --warn: #a34f2f;
      --ok: #1b7f52;
      --terminal-bg: #101712;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Trebuchet MS", "Gill Sans", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 5% -10%, #e7d9bf 0%, transparent 38%),
        radial-gradient(circle at 100% 0%, #d8e6e0 0%, transparent 36%),
        linear-gradient(180deg, #f6f1e8 0%, #efe6d8 100%);
      min-height: 100vh;
      padding: 18px;
    }

    .shell {
      max-width: 1280px;
      margin: 0 auto;
      display: grid;
      gap: 14px;
    }

    .header {
      border: 1px solid var(--line);
      background: linear-gradient(145deg, #fff9ee 0%, #f9efd9 100%);
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: 0 10px 24px rgba(59, 44, 27, 0.08);
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.02em;
    }

    .sub {
      margin-top: 4px;
      color: var(--muted);
      font-size: 13px;
    }

    .grid {
      display: grid;
      gap: 14px;
      grid-template-columns: 1fr 1fr;
    }

    .card {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      padding: 14px;
      box-shadow: 0 8px 18px rgba(59, 44, 27, 0.06);
    }

    .span2 {
      grid-column: 1 / -1;
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .row {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr 1fr;
      margin-bottom: 8px;
    }

    .row.single {
      grid-template-columns: 1fr;
    }

    .row.triple {
      grid-template-columns: 1fr 1fr 1fr;
    }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    input, select, textarea {
      width: 100%;
      border: 1px solid var(--line);
      background: #fffdf8;
      color: var(--ink);
      border-radius: 10px;
      padding: 10px;
      font: inherit;
      font-size: 13px;
    }

    textarea {
      min-height: 132px;
      resize: vertical;
      font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    button {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 12px;
      font: inherit;
      font-size: 13px;
      cursor: pointer;
      background: #fff8eb;
      color: var(--ink);
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: var(--brand);
      background: #fff2d9;
    }

    button.brand {
      background: linear-gradient(145deg, var(--brand), var(--brand-2));
      border-color: transparent;
      color: #f8fffd;
    }

    button.warn {
      background: #f8ebe6;
      border-color: #debaa9;
      color: #7b2e13;
    }

    .status {
      margin-top: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .status.ok { color: var(--ok); }
    .status.bad { color: var(--warn); }

    .log {
      border: 1px solid var(--line);
      background: var(--panel-2);
      border-radius: 12px;
      padding: 10px;
      min-height: 240px;
      max-height: 460px;
      overflow: auto;
      font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log.mini {
      min-height: 120px;
      max-height: 220px;
    }

    .hint {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
    }

    .terminal-wrap {
      border: 1px solid #1b2d22;
      border-radius: 12px;
      background: var(--terminal-bg);
      min-height: 320px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    #terminal {
      width: 100%;
      height: 360px;
      padding: 6px;
    }

    .split {
      display: grid;
      gap: 14px;
      grid-template-columns: 1.2fr 1fr;
    }

    @media (max-width: 1100px) {
      .split {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
      .row {
        grid-template-columns: 1fr;
      }
      .row.triple {
        grid-template-columns: 1fr;
      }
      #terminal {
        height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <section class="header">
      <h1>NovaAdapt Realtime Console</h1>
      <div class="sub">Bridge WebSocket control plane plus live terminal stdin/stdout streaming.</div>
    </section>

    <div class="grid">
      <section class="card">
        <h2>Connection</h2>
        <div class="row single">
          <div>
            <label for="ws-url">WebSocket URL</label>
            <input id="ws-url" value="ws://127.0.0.1:9797/ws" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="token">WebSocket Token (query)</label>
            <input id="token" placeholder="session or static token" />
          </div>
          <div>
            <label for="device-id">Device ID (query)</label>
            <input id="device-id" placeholder="required if allowlist enabled" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="bridge-http-url">Bridge HTTP URL</label>
            <input id="bridge-http-url" value="http://127.0.0.1:9797" />
          </div>
          <div>
            <label for="admin-token">Admin Token (for /auth/session)</label>
            <input id="admin-token" placeholder="static bridge token or admin session token" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="session-scopes">Session Scopes</label>
            <input id="session-scopes" value="read,run,plan,approve,reject,undo,cancel" />
          </div>
          <div>
            <label for="session-ttl">Session TTL (s)</label>
            <input id="session-ttl" type="number" value="900" min="60" max="86400" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="session-id">Session ID</label>
            <input id="session-id" placeholder="auto-filled after issue; optional for revoke" />
          </div>
          <div>
            <label for="revoke-expires-at">Revoke Expires At (unix)</label>
            <input id="revoke-expires-at" type="number" value="" min="1" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="allowlist-device-id">Allowlist Device ID</label>
            <input id="allowlist-device-id" placeholder="device id to add/remove" />
          </div>
          <div>
            <label for="allowlist-summary">Allowlist Summary</label>
            <input id="allowlist-summary" value="unknown" readonly />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="since-id">Since ID</label>
            <input id="since-id" type="number" value="0" min="0" />
          </div>
          <div>
            <label for="poll-timeout">Poll Timeout (s)</label>
            <input id="poll-timeout" type="number" value="20" min="1" />
          </div>
        </div>
        <div class="controls">
          <button id="issue-session-btn">Issue Session Token</button>
          <button id="revoke-session-btn">Revoke Session Token</button>
          <button id="devices-refresh-btn">List Devices</button>
          <button id="device-add-btn">Add Device</button>
          <button id="device-remove-btn">Remove Device</button>
          <button class="brand" id="connect-btn">Connect</button>
          <button class="warn" id="disconnect-btn">Disconnect</button>
          <button id="ping-btn">Ping</button>
        </div>
        <div class="status" id="status">Disconnected</div>
      </section>

      <section class="card">
        <h2>Command</h2>
        <div class="row">
          <div>
            <label for="command-id">Command ID</label>
            <input id="command-id" value="cmd-1" />
          </div>
          <div>
            <label for="command-method">Method</label>
            <select id="command-method">
              <option>POST</option>
              <option>GET</option>
            </select>
          </div>
        </div>
        <div class="row single">
          <div>
            <label for="command-path">Path</label>
            <input id="command-path" value="/plans/plan1/approve_async" />
          </div>
        </div>
        <div class="row single">
          <div>
            <label for="command-body">Body JSON</label>
            <textarea id="command-body">{"execute": true}</textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="idem-key">Idempotency Key</label>
            <input id="idem-key" value="" placeholder="optional" />
          </div>
          <div>
            <label for="cursor-id">Set Since ID</label>
            <input id="cursor-id" type="number" value="0" min="0" />
          </div>
        </div>
        <div class="controls">
          <button class="brand" id="send-command-btn">Send Command</button>
          <button id="set-since-btn">Set Cursor</button>
        </div>
        <div class="hint">Forwarded routes include `/run*`, `/plans/*`, `/jobs/*`, `/plugins/*`, `/memory/*`, `/terminal/sessions*`, and `/browser/*`.</div>
      </section>

      <section class="card span2">
        <h2>Browser Control</h2>
        <div class="row triple">
          <div>
            <label for="browser-message-type">Message Type</label>
            <select id="browser-message-type">
              <option value="browser_status">browser_status</option>
              <option value="browser_pages">browser_pages</option>
              <option value="browser_navigate">browser_navigate</option>
              <option value="browser_click">browser_click</option>
              <option value="browser_fill">browser_fill</option>
              <option value="browser_extract_text">browser_extract_text</option>
              <option value="browser_screenshot">browser_screenshot</option>
              <option value="browser_wait_for_selector">browser_wait_for_selector</option>
              <option value="browser_evaluate_js">browser_evaluate_js</option>
              <option value="browser_action">browser_action</option>
              <option value="browser_close">browser_close</option>
            </select>
          </div>
          <div>
            <label for="browser-page-id">Page ID (optional)</label>
            <input id="browser-page-id" placeholder="page-1" />
          </div>
          <div>
            <label for="browser-idem">Idempotency Key (optional)</label>
            <input id="browser-idem" placeholder="browser-op-123" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="browser-url">URL</label>
            <input id="browser-url" placeholder="https://example.com" />
          </div>
          <div>
            <label for="browser-selector">Selector</label>
            <input id="browser-selector" placeholder="button.submit" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="browser-value">Value / Path</label>
            <input id="browser-value" placeholder="form value or screenshot path" />
          </div>
          <div>
            <label for="browser-state">Wait State</label>
            <select id="browser-state">
              <option value="visible">visible</option>
              <option value="attached">attached</option>
              <option value="hidden">hidden</option>
              <option value="detached">detached</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="browser-timeout-ms">Timeout (ms)</label>
            <input id="browser-timeout-ms" type="number" value="15000" min="100" max="120000" />
          </div>
          <div>
            <label for="browser-full-page">Screenshot Full Page</label>
            <select id="browser-full-page">
              <option value="true">true</option>
              <option value="false">false</option>
            </select>
          </div>
        </div>
        <div class="row single">
          <div>
            <label for="browser-script">JS Script (evaluate_js)</label>
            <textarea id="browser-script">document.title</textarea>
          </div>
        </div>
        <div class="row single">
          <div>
            <label for="browser-action-json">Raw Action JSON (browser_action)</label>
            <textarea id="browser-action-json">{"type":"navigate","target":"https://example.com"}</textarea>
          </div>
        </div>
        <div class="row single">
          <div>
            <label for="browser-extra-json">Extra Body JSON (merged)</label>
            <textarea id="browser-extra-json">{}</textarea>
          </div>
        </div>
        <div class="controls">
          <button id="browser-status-btn">Status</button>
          <button id="browser-pages-btn">Pages</button>
          <button id="browser-navigate-btn">Navigate</button>
          <button id="browser-close-btn">Close</button>
          <button class="brand" id="browser-run-btn">Run Selected</button>
        </div>
        <div class="status" id="browser-status">Browser idle</div>
        <div class="log mini" id="browser-output"></div>
      </section>
    </div>

    <div class="split">
      <section class="card">
        <h2>Remote Terminal</h2>
        <div class="row">
          <div>
            <label for="terminal-session-id">Session ID</label>
            <input id="terminal-session-id" placeholder="auto-filled after start" />
          </div>
          <div>
            <label for="terminal-poll-ms">Poll Interval (ms)</label>
            <input id="terminal-poll-ms" type="number" value="250" min="75" max="2000" />
          </div>
        </div>
        <div class="row triple">
          <div>
            <label for="terminal-command">Startup Command (optional)</label>
            <input id="terminal-command" placeholder="e.g. htop" />
          </div>
          <div>
            <label for="terminal-cwd">Working Directory (optional)</label>
            <input id="terminal-cwd" placeholder="/Users/desmondpottle/Documents" />
          </div>
          <div>
            <label for="terminal-shell">Shell (optional)</label>
            <input id="terminal-shell" placeholder="/bin/zsh" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="terminal-max-chunks">Max Chunks</label>
            <input id="terminal-max-chunks" type="number" value="4000" min="200" max="20000" />
          </div>
          <div>
            <label for="terminal-sessions-select">Attach Existing Session</label>
            <select id="terminal-sessions-select"></select>
          </div>
        </div>
        <div class="controls">
          <button class="brand" id="terminal-start-btn">Start Session</button>
          <button id="terminal-refresh-btn">Refresh Sessions</button>
          <button id="terminal-attach-btn">Attach</button>
          <button class="warn" id="terminal-stop-btn">Close Session</button>
          <button id="terminal-clear-btn">Clear View</button>
        </div>
        <div class="row single">
          <div>
            <label for="terminal-input-line">Send Input (mobile fallback)</label>
            <input id="terminal-input-line" placeholder="type command and press send" />
          </div>
        </div>
        <div class="controls">
          <button id="terminal-send-line-btn">Send Line</button>
          <button id="terminal-send-ctrlc-btn">Send Ctrl+C</button>
        </div>
        <div class="terminal-wrap">
          <div id="terminal"></div>
        </div>
        <div class="status" id="terminal-status">Terminal idle</div>
      </section>

      <section class="card">
        <h2>Event Log</h2>
        <div class="log" id="log"></div>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.5.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.10.0/lib/xterm-addon-fit.min.js"></script>
  <script>
    let socket = null;
    let commandCounter = 1;
    let commandSeq = 1;
    const pendingCommands = new Map();

    let terminal = null;
    let terminalFit = null;
    let terminalSessionID = "";
    let terminalNextSeq = 0;
    let terminalPollTimer = null;
    let terminalPollInFlight = false;
    let terminalInputBuffer = "";
    let terminalInputFlushTimer = null;
    const wsSuccessTypes = new Set([
      "command_result",
      "ack",
      "pong",
      "terminal_sessions",
      "terminal_started",
      "terminal_output",
      "terminal_input_result",
      "terminal_closed",
      "browser_status",
      "browser_pages",
      "browser_action_result",
      "browser_navigate_result",
      "browser_click_result",
      "browser_fill_result",
      "browser_extract_text_result",
      "browser_screenshot_result",
      "browser_wait_for_selector_result",
      "browser_evaluate_js_result",
      "browser_closed",
    ]);

    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    const statusEl = $("status");
    const terminalStatusEl = $("terminal-status");
    const browserStatusEl = $("browser-status");

    function nowTime() {
      return new Date().toISOString().replace("T", " ").replace("Z", "");
    }

    function appendLog(label, payload) {
      const body = typeof payload === "string" ? payload : JSON.stringify(payload, null, 2);
      logEl.textContent += `[${nowTime()}] ${label}\n${body}\n\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setStatus(text, cls = "") {
      statusEl.textContent = text;
      statusEl.className = `status ${cls}`.trim();
    }

    function setTerminalStatus(text, cls = "") {
      terminalStatusEl.textContent = text;
      terminalStatusEl.className = `status ${cls}`.trim();
    }

    function setBrowserStatus(text, cls = "") {
      browserStatusEl.textContent = text;
      browserStatusEl.className = `status ${cls}`.trim();
    }

    function setBrowserOutput(payload) {
      const outputEl = $("browser-output");
      const text = typeof payload === "string" ? payload : JSON.stringify(payload, null, 2);
      outputEl.textContent = text;
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    function isWSOpen() {
      return socket && socket.readyState === WebSocket.OPEN;
    }

    function initTerminal() {
      if (terminal) {
        return;
      }
      if (!window.Terminal) {
        appendLog("error", "xterm.js failed to load");
        setTerminalStatus("xterm.js load failed", "bad");
        return;
      }

      terminal = new window.Terminal({
        cursorBlink: true,
        fontSize: 13,
        fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace',
        convertEol: true,
        theme: {
          background: "#101712",
          foreground: "#e8f5ee",
          cursor: "#7bf4ba",
          selectionBackground: "#254738",
        },
        scrollback: 8000,
      });

      terminal.open($("terminal"));
      if (window.FitAddon && window.FitAddon.FitAddon) {
        terminalFit = new window.FitAddon.FitAddon();
        terminal.loadAddon(terminalFit);
        terminalFit.fit();
      }

      terminal.writeln("NovaAdapt remote terminal ready.");
      terminal.writeln("Connect websocket, then start or attach a session.");
      terminal.writeln("");

      window.addEventListener("resize", () => {
        if (terminalFit) {
          terminalFit.fit();
        }
      });

      terminal.onData((data) => {
        if (!terminalSessionID) {
          return;
        }
        queueTerminalInput(data);
      });
    }

    function guessBridgeHTTPURLFromWS(rawWSURL) {
      try {
        const url = new URL(rawWSURL);
        url.protocol = url.protocol === "wss:" ? "https:" : "http:";
        url.pathname = "";
        url.search = "";
        url.hash = "";
        return url.toString().replace(/\/$/, "");
      } catch {
        return "";
      }
    }

    function buildBridgeHTTPURL() {
      const explicit = $("bridge-http-url").value.trim();
      if (explicit) {
        return explicit.replace(/\/$/, "");
      }
      return guessBridgeHTTPURLFromWS($("ws-url").value.trim());
    }

    function buildWSURL() {
      const raw = $("ws-url").value.trim();
      const token = $("token").value.trim();
      const deviceID = $("device-id").value.trim();
      const sinceID = Math.max(0, Number($("since-id").value || 0));
      const pollTimeout = Math.max(1, Number($("poll-timeout").value || 20));

      const url = new URL(raw);
      url.searchParams.set("since_id", String(sinceID));
      url.searchParams.set("poll_timeout", String(pollTimeout));
      url.searchParams.set("poll_interval", "0.25");
      if (token) url.searchParams.set("token", token);
      if (deviceID) url.searchParams.set("device_id", deviceID);
      return url.toString();
    }

    function flushPendingCommandsOnDisconnect() {
      for (const [id, pending] of pendingCommands.entries()) {
        clearTimeout(pending.timeout);
        pending.reject(new Error("websocket disconnected"));
        pendingCommands.delete(id);
      }
    }

    function consumePendingResult(parsed, isError) {
      if (!parsed || typeof parsed !== "object") return false;
      const id = typeof parsed.id === "string" ? parsed.id : "";
      if (!id) return false;
      const pending = pendingCommands.get(id);
      if (!pending) return false;

      clearTimeout(pending.timeout);
      pendingCommands.delete(id);

      if (isError) {
        pending.reject(new Error(parsed.error || "command error"));
        if (!pending.silentResponse) {
          appendLog("command_error", parsed);
        }
      } else {
        pending.resolve(parsed);
        if (!pending.silentResponse) {
          appendLog("command_result", parsed);
        }
      }
      return true;
    }

    function send(obj, { log = true } = {}) {
      if (!isWSOpen()) {
        throw new Error("not connected");
      }
      socket.send(JSON.stringify(obj));
      if (log) {
        appendLog("send", obj);
      }
    }

    function sendCommand(message, { timeoutMs = 15000, log = true, silentResponse = false } = {}) {
      if (!isWSOpen()) {
        return Promise.reject(new Error("websocket is not connected"));
      }
      const payload = { ...message };
      if (!payload.id) {
        payload.id = `cmd-${commandSeq++}`;
      }

      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          if (pendingCommands.has(payload.id)) {
            pendingCommands.delete(payload.id);
            reject(new Error("command timeout"));
          }
        }, timeoutMs);

        pendingCommands.set(payload.id, { resolve, reject, timeout, silentResponse });

        try {
          send(payload, { log });
        } catch (err) {
          clearTimeout(timeout);
          pendingCommands.delete(payload.id);
          reject(err);
        }
      });
    }

    async function bridgeAdminRequest(path, { method = "GET", body = null } = {}) {
      const bridgeURL = buildBridgeHTTPURL();
      const adminToken = $("admin-token").value.trim() || $("token").value.trim();
      const requestDeviceID = $("device-id").value.trim();

      if (!bridgeURL) {
        throw new Error("bridge HTTP URL is required");
      }
      if (!adminToken) {
        throw new Error("admin token is required");
      }

      const headers = {
        "Authorization": `Bearer ${adminToken}`,
      };
      if (requestDeviceID) {
        headers["X-Device-ID"] = requestDeviceID;
      }
      const init = { method, headers };
      if (body !== null) {
        headers["Content-Type"] = "application/json";
        init.body = JSON.stringify(body);
      }

      const response = await fetch(`${bridgeURL}${path}`, init);
      const raw = await response.text();
      let payload = { raw };
      try {
        payload = raw ? JSON.parse(raw) : {};
      } catch {
        // Keep raw payload for logs.
      }
      if (!response.ok) {
        const err = new Error(payload.error || `request failed (${response.status})`);
        err.status = response.status;
        err.payload = payload;
        throw err;
      }
      return { bridgeURL, status: response.status, payload };
    }

    function updateAllowlistSummary(payload) {
      const devices = Array.isArray(payload?.devices) ? payload.devices : [];
      const count = Number(payload?.count || devices.length || 0);
      const label = devices.length > 0
        ? `${count} device(s): ${devices.join(", ")}`
        : `${count} device(s)`;
      $("allowlist-summary").value = label;
    }

    async function listAllowedDevices() {
      try {
        const response = await bridgeAdminRequest("/auth/devices");
        updateAllowlistSummary(response.payload);
        appendLog("devices_list", response.payload);
        setStatus(`Loaded allowlist (${response.payload.count || 0})`, "ok");
      } catch (err) {
        appendLog("devices_list_error", {
          error: String(err),
          status: err?.status ?? null,
          payload: err?.payload ?? null,
        });
        setStatus("Allowlist load failed", "bad");
      }
    }

    async function addAllowedDevice() {
      const deviceID = $("allowlist-device-id").value.trim();
      if (!deviceID) {
        appendLog("error", "allowlist device id is required");
        return;
      }
      try {
        const response = await bridgeAdminRequest("/auth/devices", {
          method: "POST",
          body: { device_id: deviceID },
        });
        updateAllowlistSummary(response.payload);
        appendLog("device_added", response.payload);
        setStatus(`Allowlisted ${deviceID}`, "ok");
      } catch (err) {
        appendLog("device_add_error", {
          error: String(err),
          status: err?.status ?? null,
          payload: err?.payload ?? null,
        });
        setStatus("Allowlist add failed", "bad");
      }
    }

    async function removeAllowedDevice() {
      const deviceID = $("allowlist-device-id").value.trim();
      if (!deviceID) {
        appendLog("error", "allowlist device id is required");
        return;
      }
      try {
        const response = await bridgeAdminRequest("/auth/devices/remove", {
          method: "POST",
          body: { device_id: deviceID },
        });
        updateAllowlistSummary(response.payload);
        appendLog("device_removed", response.payload);
        setStatus(`Removed ${deviceID} from allowlist`, "ok");
      } catch (err) {
        appendLog("device_remove_error", {
          error: String(err),
          status: err?.status ?? null,
          payload: err?.payload ?? null,
        });
        setStatus("Allowlist remove failed", "bad");
      }
    }

    async function issueSessionToken() {
      const bridgeURL = buildBridgeHTTPURL();
      const adminToken = $("admin-token").value.trim() || $("token").value.trim();
      const deviceID = $("device-id").value.trim();
      const ttl = Math.max(60, Math.min(86400, Number($("session-ttl").value || 900)));
      const scopes = $("session-scopes").value
        .split(",")
        .map((item) => item.trim())
        .filter(Boolean);

      if (!bridgeURL) {
        appendLog("error", "bridge HTTP URL is required");
        return;
      }
      if (!adminToken) {
        appendLog("error", "admin token is required to issue a scoped session token");
        return;
      }
      if (scopes.length === 0) {
        appendLog("error", "at least one scope is required");
        return;
      }

      const headers = {
        "Authorization": `Bearer ${adminToken}`,
        "Content-Type": "application/json",
      };
      if (deviceID) {
        headers["X-Device-ID"] = deviceID;
      }

      const body = { scopes, ttl_seconds: ttl };
      if (deviceID) {
        body.device_id = deviceID;
      }

      appendLog("session_issue_request", { bridgeURL, scopes, ttl_seconds: ttl, device_id: deviceID || null });
      try {
        const response = await fetch(`${bridgeURL}/auth/session`, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
        });
        const raw = await response.text();
        let payload = { raw };
        try {
          payload = raw ? JSON.parse(raw) : {};
        } catch {
          // Keep raw payload for log visibility.
        }
        if (!response.ok) {
          appendLog("session_issue_error", { status: response.status, payload });
          setStatus(`Session issue failed (${response.status})`, "bad");
          return;
        }
        if (!payload.token) {
          appendLog("session_issue_error", { status: response.status, payload });
          setStatus("Session issue failed (missing token)", "bad");
          return;
        }
        $("token").value = payload.token;
        if (payload.session_id) {
          $("session-id").value = payload.session_id;
        }
        appendLog("session_issued", {
          session_id: payload.session_id,
          subject: payload.subject,
          scopes: payload.scopes,
          device_id: payload.device_id,
          expires_at: payload.expires_at,
          issued_at: payload.issued_at,
        });
        setStatus("Session token issued", "ok");
      } catch (err) {
        appendLog("session_issue_error", String(err));
        setStatus("Session issue network error", "bad");
      }
    }

    async function revokeSessionToken() {
      const bridgeURL = buildBridgeHTTPURL();
      const adminToken = $("admin-token").value.trim();
      const tokenToRevoke = $("token").value.trim();
      const sessionID = $("session-id").value.trim();
      const revokeExpiresAt = Number($("revoke-expires-at").value || 0);

      if (!bridgeURL) {
        appendLog("error", "bridge HTTP URL is required");
        return;
      }
      if (!adminToken) {
        appendLog("error", "admin token is required to revoke a session token");
        return;
      }
      if (!tokenToRevoke && !sessionID) {
        appendLog("error", "session token or session id is required to revoke");
        return;
      }

      const headers = {
        "Authorization": `Bearer ${adminToken}`,
        "Content-Type": "application/json",
      };
      const body = {};
      if (tokenToRevoke) {
        body.token = tokenToRevoke;
      }
      if (sessionID) {
        body.session_id = sessionID;
      }
      if (Number.isFinite(revokeExpiresAt) && revokeExpiresAt > 0) {
        body.expires_at = Math.floor(revokeExpiresAt);
      }

      appendLog("session_revoke_request", { bridgeURL, body });
      try {
        const response = await fetch(`${bridgeURL}/auth/session/revoke`, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
        });
        const raw = await response.text();
        let payload = { raw };
        try {
          payload = raw ? JSON.parse(raw) : {};
        } catch {
          // Keep raw payload for log visibility.
        }
        if (!response.ok) {
          appendLog("session_revoke_error", { status: response.status, payload });
          setStatus(`Session revoke failed (${response.status})`, "bad");
          return;
        }
        appendLog("session_revoked", payload);
        setStatus("Session token revoked", "ok");
      } catch (err) {
        appendLog("session_revoke_error", String(err));
        setStatus("Session revoke network error", "bad");
      }
    }

    function connect() {
      if (isWSOpen()) {
        appendLog("info", "already connected");
        return;
      }

      const wsURL = buildWSURL();
      appendLog("connect", { wsURL });
      socket = new WebSocket(wsURL);

      socket.onopen = () => {
        setStatus("Connected", "ok");
        setTerminalStatus("WebSocket connected", "ok");
        setBrowserStatus("WebSocket connected", "ok");
        refreshTerminalSessions();
        if (terminalSessionID) {
          startTerminalPolling(true);
        }
      };
      socket.onclose = (event) => {
        stopTerminalPolling();
        flushPendingCommandsOnDisconnect();
        setStatus(`Disconnected (${event.code})`, "bad");
        setTerminalStatus("Terminal disconnected", "bad");
        setBrowserStatus("Browser controls disconnected", "bad");
        appendLog("close", { code: event.code, reason: event.reason });
      };
      socket.onerror = () => {
        setStatus("Connection error", "bad");
      };
      socket.onmessage = (event) => {
        let parsed = null;
        try {
          parsed = JSON.parse(event.data);
        } catch {
          appendLog("message", event.data);
          return;
        }

        if (wsSuccessTypes.has(parsed.type) && consumePendingResult(parsed, false)) {
          return;
        }
        if (parsed.type === "error" && consumePendingResult(parsed, true)) {
          return;
        }

        appendLog(parsed.type || "message", parsed);
      };
    }

    function disconnect() {
      if (!socket) return;
      socket.close(1000, "manual disconnect");
      socket = null;
    }

    async function refreshTerminalSessions() {
      if (!isWSOpen()) {
        return;
      }
      try {
        const response = await sendCommand(
          {
            type: "terminal_list",
            id: `terminal-list-${Date.now()}`,
          },
          { log: false, silentResponse: true }
        );
        if (response.status < 200 || response.status >= 300) {
          throw new Error(`status ${response.status}`);
        }
        const rows = Array.isArray(response.payload) ? response.payload : [];
        const select = $("terminal-sessions-select");
        select.innerHTML = "";
        const empty = document.createElement("option");
        empty.value = "";
        empty.textContent = rows.length ? "Select session" : "No sessions";
        select.appendChild(empty);
        for (const row of rows) {
          const id = String(row.id || "");
          if (!id) continue;
          const option = document.createElement("option");
          option.value = id;
          option.textContent = `${id}${row.open ? " (open)" : " (closed)"}`;
          select.appendChild(option);
        }
      } catch (err) {
        appendLog("terminal_sessions_error", String(err));
      }
    }

    function attachTerminalSession(sessionID) {
      const id = String(sessionID || "").trim();
      if (!id) {
        return;
      }
      terminalSessionID = id;
      terminalNextSeq = 0;
      $("terminal-session-id").value = id;
      setTerminalStatus(`Attached to session ${id}`, "ok");
      if (terminal) {
        terminal.writeln(`\r\n[attached ${id}]`);
      }
      startTerminalPolling(true);
    }

    async function startTerminalSession() {
      if (!isWSOpen()) {
        setTerminalStatus("Connect websocket first", "bad");
        return;
      }
      const body = {
        max_chunks: Math.max(200, Math.min(20000, Number($("terminal-max-chunks").value || 4000))),
      };
      const command = $("terminal-command").value.trim();
      const cwd = $("terminal-cwd").value.trim();
      const shell = $("terminal-shell").value.trim();
      if (command) body.command = command;
      if (cwd) body.cwd = cwd;
      if (shell) body.shell = shell;

      try {
        const response = await sendCommand(
          {
            type: "terminal_start",
            body,
            id: `terminal-start-${Date.now()}`,
          },
          { log: true }
        );
        if (response.status !== 201 && response.status !== 200) {
          throw new Error(`terminal start failed: status ${response.status}`);
        }
        const payload = response.payload || {};
        const id = String(payload.id || "").trim();
        if (!id) {
          throw new Error("terminal start response missing session id");
        }
        attachTerminalSession(id);
        refreshTerminalSessions();
      } catch (err) {
        appendLog("terminal_start_error", String(err));
        setTerminalStatus("Failed to start terminal session", "bad");
      }
    }

    async function closeTerminalSession() {
      if (!isWSOpen()) {
        setTerminalStatus("Connect websocket first", "bad");
        return;
      }
      const id = $("terminal-session-id").value.trim() || terminalSessionID;
      if (!id) {
        setTerminalStatus("No terminal session selected", "bad");
        return;
      }

      try {
        const response = await sendCommand(
          {
            type: "terminal_close",
            session_id: id,
            id: `terminal-close-${Date.now()}`,
          },
          { log: true }
        );
        if (response.status < 200 || response.status >= 300) {
          throw new Error(`status ${response.status}`);
        }
        setTerminalStatus(`Closed session ${id}`, "ok");
        stopTerminalPolling();
        terminalSessionID = "";
        terminalNextSeq = 0;
        $("terminal-session-id").value = "";
        refreshTerminalSessions();
      } catch (err) {
        appendLog("terminal_close_error", String(err));
        setTerminalStatus("Failed to close terminal session", "bad");
      }
    }

    function stopTerminalPolling() {
      if (terminalPollTimer) {
        clearInterval(terminalPollTimer);
        terminalPollTimer = null;
      }
      terminalPollInFlight = false;
    }

    function startTerminalPolling(runImmediately = false) {
      stopTerminalPolling();
      if (!terminalSessionID || !isWSOpen()) {
        return;
      }
      const pollMs = Math.max(75, Math.min(2000, Number($("terminal-poll-ms").value || 250)));
      if (runImmediately) {
        pollTerminalOutput();
      }
      terminalPollTimer = setInterval(() => {
        pollTerminalOutput();
      }, pollMs);
    }

    async function pollTerminalOutput() {
      if (!terminalSessionID || !isWSOpen() || terminalPollInFlight) {
        return;
      }
      terminalPollInFlight = true;
      try {
        const response = await sendCommand(
          {
            type: "terminal_poll",
            session_id: terminalSessionID,
            since_seq: terminalNextSeq,
            limit: 600,
            id: `terminal-poll-${Date.now()}`,
          },
          { log: false, silentResponse: true, timeoutMs: 12000 }
        );
        if (response.status < 200 || response.status >= 300) {
          throw new Error(`poll status ${response.status}`);
        }

        const payload = response.payload || {};
        const chunks = Array.isArray(payload.chunks) ? payload.chunks : [];
        for (const chunk of chunks) {
          const seq = Number(chunk.seq || 0);
          if (seq > terminalNextSeq) {
            terminalNextSeq = seq;
          }
          if (terminal && typeof chunk.data === "string" && chunk.data.length) {
            terminal.write(chunk.data);
          }
        }
        if (payload.next_seq && Number(payload.next_seq) > terminalNextSeq) {
          terminalNextSeq = Number(payload.next_seq);
        }
        const open = payload.open !== false;
        const suffix = open ? "open" : `closed (${payload.exit_code ?? "?"})`;
        setTerminalStatus(`Session ${terminalSessionID}: ${suffix}, seq ${terminalNextSeq}`, open ? "ok" : "bad");
      } catch (err) {
        setTerminalStatus(`Terminal poll error: ${String(err)}`, "bad");
      } finally {
        terminalPollInFlight = false;
      }
    }

    function queueTerminalInput(data) {
      terminalInputBuffer += data;
      if (terminalInputFlushTimer) {
        return;
      }
      terminalInputFlushTimer = setTimeout(() => {
        flushTerminalInput();
      }, 35);
    }

    async function flushTerminalInput() {
      if (!terminalInputFlushTimer) {
        return;
      }
      clearTimeout(terminalInputFlushTimer);
      terminalInputFlushTimer = null;

      if (!terminalInputBuffer || !terminalSessionID || !isWSOpen()) {
        terminalInputBuffer = "";
        return;
      }
      const payload = terminalInputBuffer;
      terminalInputBuffer = "";

      try {
        const response = await sendCommand(
          {
            type: "terminal_input",
            session_id: terminalSessionID,
            input: payload,
            id: `terminal-input-${Date.now()}`,
          },
          { log: false, silentResponse: true }
        );
        if (response.status < 200 || response.status >= 300) {
          throw new Error(`input status ${response.status}`);
        }
      } catch (err) {
        appendLog("terminal_input_error", String(err));
      }
    }

    async function sendTerminalLine() {
      const value = $("terminal-input-line").value;
      if (!value) {
        return;
      }
      $("terminal-input-line").value = "";
      queueTerminalInput(value + "\n");
      await flushTerminalInput();
    }

    async function sendTerminalCtrlC() {
      queueTerminalInput("\u0003");
      await flushTerminalInput();
    }

    function parseOptionalJSONObject(raw, label) {
      const trimmed = String(raw || "").trim();
      if (!trimmed) {
        return null;
      }
      let parsed = null;
      try {
        parsed = JSON.parse(trimmed);
      } catch (err) {
        throw new Error(`invalid ${label}: ${String(err)}`);
      }
      if (!parsed || Array.isArray(parsed) || typeof parsed !== "object") {
        throw new Error(`${label} must be a JSON object`);
      }
      return parsed;
    }

    function maybeAttachPageID(body) {
      const pageID = $("browser-page-id").value.trim();
      if (pageID) {
        body.page_id = pageID;
      }
    }

    function mergedBrowserBody(baseBody) {
      const body = { ...baseBody };
      const extra = parseOptionalJSONObject($("browser-extra-json").value, "browser extra json");
      if (extra) {
        Object.assign(body, extra);
      }
      return body;
    }

    function buildBrowserBody(msgType) {
      const url = $("browser-url").value.trim();
      const selector = $("browser-selector").value.trim();
      const value = $("browser-value").value;
      const script = $("browser-script").value.trim();
      const timeoutMs = Math.max(100, Number($("browser-timeout-ms").value || 15000));

      if (msgType === "browser_action") {
        const action = parseOptionalJSONObject($("browser-action-json").value, "browser action json");
        if (!action) {
          throw new Error("browser action json is required");
        }
        maybeAttachPageID(action);
        return mergedBrowserBody(action);
      }

      const body = {};
      maybeAttachPageID(body);

      if (msgType === "browser_navigate") {
        if (!url) throw new Error("URL is required for browser_navigate");
        body.url = url;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_click") {
        if (!selector) throw new Error("Selector is required for browser_click");
        body.selector = selector;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_fill") {
        if (!selector) throw new Error("Selector is required for browser_fill");
        body.selector = selector;
        body.value = value;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_extract_text") {
        if (!selector) throw new Error("Selector is required for browser_extract_text");
        body.selector = selector;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_screenshot") {
        const path = value.trim();
        if (path) body.path = path;
        body.full_page = $("browser-full-page").value === "true";
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_wait_for_selector") {
        if (!selector) throw new Error("Selector is required for browser_wait_for_selector");
        body.selector = selector;
        body.state = $("browser-state").value;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }
      if (msgType === "browser_evaluate_js") {
        if (!script) throw new Error("Script is required for browser_evaluate_js");
        body.script = script;
        body.timeout_ms = timeoutMs;
        return mergedBrowserBody(body);
      }

      return mergedBrowserBody(body);
    }

    async function sendBrowserCommand(msgType) {
      if (!isWSOpen()) {
        throw new Error("websocket is not connected");
      }
      const timeoutMs = Math.max(500, Number($("browser-timeout-ms").value || 15000));
      const message = {
        type: msgType,
        id: `${msgType}-${Date.now()}`,
      };
      const idem = $("browser-idem").value.trim();
      if (idem) {
        message.idempotency_key = idem;
      }

      if (!["browser_status", "browser_pages", "browser_close"].includes(msgType)) {
        message.body = buildBrowserBody(msgType);
      }

      const response = await sendCommand(message, { log: true, silentResponse: true, timeoutMs });
      setBrowserOutput(response.payload ?? response);
      if (response.status >= 200 && response.status < 300) {
        setBrowserStatus(`${msgType} ok (${response.status})`, "ok");
      } else {
        setBrowserStatus(`${msgType} failed (${response.status})`, "bad");
      }
      appendLog("browser_result", response);
      return response;
    }

    async function runSelectedBrowserCommand() {
      const msgType = $("browser-message-type").value;
      try {
        await sendBrowserCommand(msgType);
      } catch (err) {
        appendLog("browser_error", String(err));
        setBrowserStatus(String(err), "bad");
      }
    }

    $("issue-session-btn").addEventListener("click", () => {
      issueSessionToken();
    });
    $("revoke-session-btn").addEventListener("click", () => {
      revokeSessionToken();
    });
    $("devices-refresh-btn").addEventListener("click", () => {
      listAllowedDevices();
    });
    $("device-add-btn").addEventListener("click", () => {
      addAllowedDevice();
    });
    $("device-remove-btn").addEventListener("click", () => {
      removeAllowedDevice();
    });
    $("connect-btn").addEventListener("click", connect);
    $("disconnect-btn").addEventListener("click", disconnect);

    $("ping-btn").addEventListener("click", async () => {
      try {
        await sendCommand({ type: "ping", id: `ping-${Date.now()}` }, { log: true, silentResponse: false, timeoutMs: 5000 });
      } catch (err) {
        appendLog("ping_error", String(err));
      }
    });

    $("set-since-btn").addEventListener("click", async () => {
      const value = Math.max(0, Number($("cursor-id").value || 0));
      try {
        await sendCommand(
          { type: "set_since_id", id: `cursor-${Date.now()}`, since_id: value },
          { log: true }
        );
        $("since-id").value = String(value);
      } catch (err) {
        appendLog("cursor_error", String(err));
      }
    });

    $("send-command-btn").addEventListener("click", async () => {
      let body = null;
      const rawBody = $("command-body").value.trim();
      if (rawBody) {
        try {
          body = JSON.parse(rawBody);
        } catch (err) {
          appendLog("error", `invalid JSON body: ${String(err)}`);
          return;
        }
      }

      const msg = {
        type: "command",
        id: $("command-id").value.trim() || `cmd-${commandCounter++}`,
        method: $("command-method").value.trim(),
        path: $("command-path").value.trim(),
      };
      const idem = $("idem-key").value.trim();
      if (idem) msg.idempotency_key = idem;
      if (body !== null) msg.body = body;

      try {
        await sendCommand(msg, { log: true });
      } catch (err) {
        appendLog("command_send_error", String(err));
      }
    });

    $("ws-url").addEventListener("change", () => {
      const guessed = guessBridgeHTTPURLFromWS($("ws-url").value.trim());
      if (guessed && !$("bridge-http-url").value.trim()) {
        $("bridge-http-url").value = guessed;
      }
    });

    $("terminal-start-btn").addEventListener("click", () => {
      startTerminalSession();
    });

    $("terminal-refresh-btn").addEventListener("click", () => {
      refreshTerminalSessions();
    });

    $("terminal-attach-btn").addEventListener("click", () => {
      const selected = $("terminal-sessions-select").value.trim();
      if (!selected) {
        return;
      }
      attachTerminalSession(selected);
    });

    $("terminal-stop-btn").addEventListener("click", () => {
      closeTerminalSession();
    });

    $("terminal-clear-btn").addEventListener("click", () => {
      if (terminal) {
        terminal.clear();
      }
    });

    $("terminal-send-line-btn").addEventListener("click", () => {
      sendTerminalLine();
    });

    $("terminal-send-ctrlc-btn").addEventListener("click", () => {
      sendTerminalCtrlC();
    });

    $("browser-run-btn").addEventListener("click", () => {
      runSelectedBrowserCommand();
    });

    $("browser-status-btn").addEventListener("click", () => {
      $("browser-message-type").value = "browser_status";
      runSelectedBrowserCommand();
    });

    $("browser-pages-btn").addEventListener("click", () => {
      $("browser-message-type").value = "browser_pages";
      runSelectedBrowserCommand();
    });

    $("browser-navigate-btn").addEventListener("click", () => {
      $("browser-message-type").value = "browser_navigate";
      runSelectedBrowserCommand();
    });

    $("browser-close-btn").addEventListener("click", () => {
      $("browser-message-type").value = "browser_close";
      runSelectedBrowserCommand();
    });

    $("terminal-poll-ms").addEventListener("change", () => {
      if (terminalSessionID) {
        startTerminalPolling(false);
      }
    });

    $("terminal-session-id").addEventListener("change", () => {
      const id = $("terminal-session-id").value.trim();
      if (id) {
        attachTerminalSession(id);
      }
    });

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./service-worker.js").catch((err) => {
        appendLog("sw_register_error", String(err));
      });
    }

    initTerminal();
    appendLog("ready", "Console loaded");
  </script>
</body>
</html>
